schema = production+:ps -> schema(ps)
production = tag:t token('::=') argList:a token(';') -> production(t, a)

functor = (spaces ( (functorHole functorHole !(reserved("hole-tagged-hole")))
                  | ('.'? functorHole)
                  | (tag:t functorHole:h) -> taggedHole(t, h)))
          | super

arg = interleave:l (token('|') interleave)*:r -> _or(l, *r)
interleave = action:l (token('&') action)*:r -> interleave(l, *r)
action = pred:l (token('->') pred:r -> action(l, *r)
                |                   -> l)
pred = some | (token('!') some:x -> not(x))
some = (quant:q -> some(None, q)
       | ( prim:l ( (token('**') prim:r -> matchSeparatedSequence(l, r))
                  | (token('++') prim:r -> matchSeparatedSequence1(l, r))
                  )?:seq
           quant?:q -> some(seq or l, q)))
quant = token('?') | token('+') | token('*')
prim = term
     | ('.' -> any())
     | (literal:l token('..') literal:r -> range(l, r))
     | token('^') string:s -> anyOf(s)
     | token('(') argList:l token(')') -> l

simpleint = decdigits:ds -> int(ds)
functorHole = '$'        (simpleint:i | '{' simpleint:i '}' | (tag:t -> t.name):i) -> dollarHole(i)
            |('@' | '=') (simpleint:i | '{' simpleint:i '}' | (tag:t -> t.name):i) -> patternHole(i)