#TreeTransformer
Grammar(@name repr:tree @rules) {{{
from terml.nodes import termMaker as t
from ometa.runtime import InputStream
from ometa.vm_runtime import VM, VMWrapper
def createParserClass(GrammarBase, ruleGlobals):
    rules = {
        $rules
    }
    if $tree:
        mkInput = InputStream.fromIterable
    else:
        mkInput = InputStream.fromText
    def makeParser(data):
        vm = VM(rules, mkInput(data), $tree, GrammarBase, ruleGlobals)
        return VMWrapper(vm)
    return makeParser
}}}
Rule(@name @instrs) {{{
'$name': [
    $instrs
],
}}}

Ascend() --> t.Ascend(),
Bind(repr:x) --> t.Bind($x),
Call(repr:x) --> t.Call($x),
Choice(repr:x) --> t.Choice($x),
RepeatChoice(repr:x) --> t.RepeatChoice($x),
RepeatCommit(repr:x) --> t.RepeatCommit($x),
Commit(repr:x) --> t.Commit($x),
Descend() --> t.Descend(),
EndSlice() --> t.EndSlice(),
Fail() --> t.Fail(),
ForeignCall(repr:x repr:y) --> t.ForeignCall($x, $y),
Match(repr:x) --> t.Match($x),
Predicate() --> t.Predicate(),
Push() --> t.Push(),
Python(repr:x) --> t.Python($x),
StartSlice() --> t.StartSlice(),
StringTemplate(stPart*:parts) !(', '.join(parts)):partsStr --> t.StringTemplate($partsStr)
SuperCall(repr:x) --> t.SuperCall($x),
TermDescend(repr:name) --> t.TermDescend($name),
ListAppend() --> t.ListAppend(),
CollectList() --> t.CollectList(),

repr :s = ?(s.tag.name == 'true') -> 'True'
repr :s = ?(s.tag.name == 'false') -> 'False'
repr :s = ?(s.tag.name == 'null') -> 'None'
repr :s ?(s.data is not None) -> repr(s.data)

stPart = QuasiExprHole(repr:n) --> t.QuasiExprHole($n)
stPart = repr:s -> s