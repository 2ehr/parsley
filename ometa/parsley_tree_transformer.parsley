termPattern = indentation? name:name ?(name[0].isupper())
              '(' expr:patts ')' -> t.TermPattern(name, patts)

subtransform = "@" name:n -> t.Bind(n, t.Apply('transform', self.rulename, []))

wide_templatedValue = token("-->") ' '* wideTemplateBits:contents -> t.StringTemplate(contents)
tall_templatedValue = hspace? '{{{' (' ' | '\t')* vspace? tallTemplateBits:contents '}}}' -> t.StringTemplate(contents)

tallTemplateBits = (exprHole | tallTemplateText)*
tallTemplateText = <(~('}}}' | '$' | '\r' | '\n') anything | '$' '$')+ vspace*> | vspace

wideTemplateBits = (exprHole | wideTemplateText)*
wideTemplateText = <(~(vspace | end |'$') anything | '$' '$')+>

exprHole = '$' name:n -> t.QuasiExprHole(n)

expr1 = foreignApply
       |termPattern
       |subtransform
       |application
       |ruleValue
       |wide_templatedValue
       |tall_templatedValue
       |semanticPredicate
       |semanticAction
       |number:n !(self.isTree()) -> n
       |character
       |string
       |token('(') expr:e token(')') -> e
       |token('[') expr?:e token(']') -> t.TermPattern(".tuple.", e or t.And([]))

grammar = rule*:rs spaces -> t.Grammar(self.name, True, rs)
